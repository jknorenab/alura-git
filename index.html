<!DOCTYPE html>
<!--Este documento tiene como objeto revisar git y github-->

<html lang = "en">
<head>
     <meta charset = "UTF-8">
     <title> Lista de Cursos de DevOps de Alura </title>
     <!--Branches: Son como bifurcaciones de nuestro código que nos permite trabajar simultáneamente sobre los archivos pero en diferentes líneas de código: Revisar https://git-school.github.io/visualizing-git/ para más detalles
     git branch (lista las ramas que tengo en mi repositorio)
     git branch nombreRama (crea una nueva rama)
     git checkout nombreRamaDestino (nos cambia de la rama actual a la nueva rama nombreRamaDestino)
     git checkout -b nuevaRama (este nos permite crear una rama nuevaRama y luego movernos a ella para empezar a trabajar allí)
     -->
</head>
<body>
     <ul>
         <li> Vagrant: Gerenciando máquinas virtuales </li>
         <li> Docker: Creando containers sin dolor de cabeza </li>
         <!--Tambien podemos guardar el estado de un archivo sin hacerle commit con el comando git stash Esto permite guardar los cambios y modificaciones con un estado de Work in progress WIP y nos da un hash (identificador) ef5063a para, posiblemente, volver a ellos. En este sentido podemos ver la lista de cambios guardados con git stash list . Así luego podremos hacer git stash apply IDdelCambioGuardado esto aplicará los cambios guardados al archivo en curso, pero mantendrá los cambios en stash, así que luego tendremos que hacer git stash drop para eliminar dichos cambios de la lista de cambios "pendientes". Para aplicar la última modificación de la lista de stash y eliminarla simultáneamente de la lista usamos: git stash pop  -->
         <li> Ansible: Infraestructura como código </li>
         <!--Cómo se hace ctrl+z en git? Pues, si no hemos puesto el archivo en el stage area, basta con usar git restore nombreDelArchivo. Por otro lado, si ya lo pusimos en el stage area, debemos usar        git restore --stage nombreDelArchivo. Con eso lo saca del stage area y las modificaciones se mantienen sin monitorearse. Por último, si ya añadimos el archivo al stage area y le hicimos commit, pero nos dimos cuenta de que ese commit no funcionaba, entonces usamos el comando                     git revert idDelCommitErroneo Esto creará un nuevo commit que revierte el commit equivocado-->
         <li> Integración continua: Madurez y Productividad en el Desarrollo de Software </li> <!--Ana añade una descripción más detallada al título de este curso para ver la transferencia de información entre servidor y repos locales--> 
         <li> HTML CSS JavaScript </li>
         <!-- Podemos ver el historial de commits con git log. Este comando tiene banderas muy interesantes: git log --oneline-> permite ver el historial de commits reducidos sólo a una línea; git log -p-> permite ver en detalle los cambios del archivo, la línea que se modificó o se insertó (o se borró). Podemos consultar más banderas de este comando aquí: https://devhints.io/git-log -->
         <!--Además, con git log --graph podemos ver de forma gráfica el timeline de los commits, incluyendo las branches y sus merges-->
     <!--Ahora para juntar el trabajo podemos usar desde la rama principal (tallo, para nuestra visualización) que para el caso es la rama master, el comando git merge ramaQueQueremosJuntarAlMaster. Este comando juntará ambas ramas, sin embargo en el historial no aparecerán los commits que hicimos en la rama que queremos mergear(los cambios de los commits sí que aparecerán, pero no el historial de commits). Lo que puede ocasionar confusiones. 
     Por otro lado, si queremos que la rama master (rama principal) tenga el historial de la rama que queremos unirle, podemos usar git rebase ramaQueQueremosJuntarAlMaster el resultado es el mismo, pero ahora, al hacer git rebase, la rama master contiene todo el historial de commits que se hicieron previamente sólo en la rama alterna -->
         <li> Kubernetes: Introducción a la orquestación de containers </li> <!--Lista añadida como parte del ejercicio en ramas-->
     </ul>
     <!--En cuanto a cuando se debe hacer commit, es importante NUNCA hacer commit de un código que no funciona, y es recomendable hacer commits cada vez que se hace un cambio significatio, algunas personas lo hacen cada vez que agregan un línea, y aunque esto no es lo mejor, sí es importante dividir los committs grandes en pequeños trozos, para evitar un commit gigante al final del día-->
</body>
<!--Creamos un nuevo repositorio (servidor) pero que va a servir como servidor: Es decir no tiene una copia de los archivos que está monitoreando sino que sólo recibe los cambios de la carpeta repo. Para configurarlo como servidor de la carpeta repo, debemos usar: git remote add nombreDelServidor direccion (en estas instrucciones estamos teniendo en cuenta los espacios, no olvidarlos) Además, esta dirección puede ser cualquier cosa que contenga un servidor git: Una link en la web, una carpeta local, un cluster. El comando git remote lista todos los servidores conectados a mi repositorio, y el comando git remote -v indica las direcciones del servidor con los comandos fecth (el lugar del que vamos a obtener la información del servidor remoto) y push (el lugar al que vamos a enviar la información del servidor )-->
<!--Fingimos un nuevo usuario: Ana, que quiere clonar nuestro repositorio, así el comando sería: git clone direccionRepoAClonar nombreCarpetaQueLeQuieroDar(opcional) Hay que tener cuidado con la dirección del repositorio que queremos clonar, lo escribimos (para este ejemplo) como: /d/Kathe/Documents/2022-2/ORACLE/Curso8-Git/servidor/ -->
<!--Enviamos información de nuestro repositorio local al remoto a través del comando: git push nombreRepositorioRemoto (o sea, destino) ramaQueQuieroEnviar (o sea origen)-->
<!--Cuando nosotros agregamos un repositorio remoto git le pone nombre por defecto: origin. Podemos renombrarlo usando el comando git remote renome nombreActual nuevoNombre-->
<!--Finalmente para que Ana traiga la información del repo, usamos git pull nombreRepositorioRemoto (o sea donde está la información que quiero traer) ramaQueQuieroTraer (o sea rama que quiero copiar)-->
<!--Ahora, configuramos un repositorio no local, sino en la web con GitHub. GitHub nos provee una interfaz super rica para controlar y manejar nuestro repositorio remoto. Lo importante a considerar son los comandos para compartir información: 

     git remote add origin https://github.com/jknorenab/alura-git.git  Aquí, le estamos diciendo a nuestro repositorio local que se conecte con un repositorio remoto con nombre Origin localizado en la web. Origin es el nombre por defecto del repositorio remoto en Github. 

     git push -u  origin master  Envía la información que tenemos en nuestra rama local master a la rama remota master en el repositorio remoto Origin, la bandera -u nos permite conectarles permanentemente, de forma que todo lo que envío desde master (localmente) va a master (remotamente). Esto permite que luego de este comando baste con hacer git push, para enviar los archivos e informaciones. El comando: git push origin master me permite tener más control sobre la rama desde la que envío y la rama a la que llega, de modo que si no uso la bandera -u, tendré siempre que indicar desde donde tomo y hacia donde lo envío
-->
</html>